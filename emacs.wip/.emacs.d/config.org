#+TITLE: Emacs configuration

* Bootstrap
** Identity

#+BEGIN_SRC emacs-lisp
(setq user-full-name "Amol Mandhane"
      user-mail-address "amol.mandhane@gmail.com")
#+END_SRC

** Ensure `use-package`
#+BEGIN_SRC emacs-lisp
(require 'package)
(package-initialize)
(setq package-archives '(("gnu" . "https://elpa.gnu.org/packages/")
                         ;; ("marmalade" . "http://marmalade-repo.org/packages/")
                         ("melpa" . "https://melpa.org/packages/")
                         ("org" . "http://orgmode.org/elpa/")))

(unless (package-installed-p 'use-package)
  (package-refresh-contents)
  (package-install 'use-package))
#+END_SRC

** Add ~/.emacs.d/lisp to `load-path`
#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path (expand-file-name "~/.emacs.d/lisp"))
#+END_SRC

** Set up `exec-path` correctly
#+BEGIN_SRC emacs-lisp
  (use-package exec-path-from-shell
    :ensure t
    :config
    (exec-path-from-shell-initialize))
#+END_SRC

* Daemon
#+BEGIN_SRC emacs-lisp
  (add-hook 'after-init-hook #'(lambda () (server-start)))
#+END_SRC
* Keybinding framework
** Hydra
#+BEGIN_SRC emacs-lisp
(use-package hydra :ensure t)
#+END_SRC
** Mnemonics
Spacemacs like mnemonics are great to remember keybindings. Following code
creates a framework like that using `bind-key`.

#+BEGIN_SRC emacs-lisp
(global-unset-key (kbd "M-m"))
(require 'keybinding)
#+END_SRC
** Key-chord
#+BEGIN_SRC emacs-lisp
  (use-package key-chord
    :ensure t
    :init
    (progn (setq key-chord-two-keys-delay 0.05))
    :config (key-chord-mode +1))
#+END_SRC
* Interface framework
Current iteration of interface framework is combination of IDO and Ivy. Helm is proving difficult to
configure exactly like I want.

Approach to evolve interface framework
 + Current: Use Ivy/Counsel everywhere with fuzzy matching for selected functions. Fallback to
   well-configured Ido+smex.
 + Past: Use IDO as much as possible and switch to Ivy when IDO doesn't cut it.

** IDO
#+BEGIN_SRC emacs-lisp
(use-package smex
  :ensure t)
(use-package ido-ubiquitous
  :ensure t)
(use-package ido-vertical-mode
  :ensure t)
(use-package flx
  :ensure t)
(use-package flx-ido
  :ensure t
  :after ido
  :after flx
  :config (flx-ido-mode +1))

(use-package ido
  :ensure t
  :after smex
  :after ido-ubiquitous
  :after ido-vertical-mode
  :config
  (progn
    (setq ido-enable-flex-matching t)
    (setq ido-use-virtual-buffers t)
    (setq ido-enable-regex t)

    (add-hook
      'ido-setup-hook
      (lambda () (mode-keys
                   ido-completion-map
                   ("<tab>" . ido-exit-minibuffer)
                   ("<return>" . ido-exit-minibuffer))))

    (ido-mode +1)
    (ido-everywhere +1)
    (ido-ubiquitous-mode +1)
    (ido-vertical-mode +1)

    (require 'smex)
    (smex-initialize)))

#+END_SRC

** Ivy
#+BEGIN_SRC emacs-lisp
(use-package counsel
  :ensure t)
(use-package ivy
  :ensure t
  :after flx
  :after counsel
  :diminish ivy-mode
  :config
  (progn
    (setq ivy-use-virtual-buffers t)
    (setq enable-recursive-minibuffers t)
    (setq ivy-count-format "[%d / %d] ")
    (ivy-mode +1)
    (setq ivy-re-builders-alist
          '((counsel-M-x . ivy--regex-fuzzy)
            (counsel-find-file . ivy--regex-fuzzy)
            (t . ivy--regex-plus)))
    (global-keys
      ("M-x" . counsel-M-x)
      ("C-c M-x" . execute-extended-command)
      ("C-x C-f" . counsel-find-file))))
#+END_SRC

* Basic setup
** Load helper functions
#+BEGIN_SRC emacs-lisp
(require 'helper-functions)
#+END_SRC
** General config
#+BEGIN_SRC emacs-lisp
  (setq delete-old-versions -1)		; delete excess backup versions silently
  (setq version-control t)		; use version control
  (setq vc-make-backup-files t)		; make backups file even when in version controlled dir
  (setq backup-directory-alist `(("." . "~/.emacs.d/backups"))) ; which directory to put backups file
  (setq vc-follow-symlinks t)				       ; don't ask for confirmation when opening symlinked file
  (setq auto-save-file-name-transforms '((".*" "~/.emacs.d/auto-save-list/" t))) ;transform backups file name
  (setq inhibit-startup-screen t)	; inhibit useless and old-school startup screen
  (setq coding-system-for-read 'utf-8)	; use utf-8 by default
  (setq coding-system-for-write 'utf-8)
  (setq sentence-end-double-space nil)	; sentence SHOULD end with only a point.
  (setq fill-column 80)		; toggle wrapping text at the 80th character
  (setq visible-bell t)                   ; Show the bell alert using visible flashes than audio dings.

  (scroll-bar-mode -1)
  (tool-bar-mode -1)

  (global-linum-mode t)
  (global-auto-revert-mode nil)
  (diminish 'auto-revert-mode)

  (line-number-mode t)
  (column-number-mode t)
  (size-indication-mode t)
  (global-hl-line-mode t)

  (defalias 'yes-or-no-p 'y-or-n-p)

  (setq ns-use-srgb-colorspace nil)

  (setq require-final-newline t)

  (set-frame-font "Inconsolata-18")
  (setq default-frame-alist '((font . "Inconsolata-18")))

  (setq-default cursor-type 'bar)
  (blink-cursor-mode 0)
#+END_SRC

** Whitespace cleanup
#+BEGIN_SRC emacs-lisp
(add-hook 'before-save-hook 'delete-trailing-whitespace)
#+END_SRC

** Text zoom
#+BEGIN_SRC emacs-lisp
(defhydra text-zoom ()
  "zoom"
  ("g" text-scale-increase "in")
  ("l" text-scale-decrease "out"))

(prefixed-key "zz" text-zoom/body)
#+END_SRC

** Annoying arrows
#+BEGIN_SRC emacs-lisp
  (use-package annoying-arrows-mode
    :ensure t
    :diminish annoying-arrows-mode
    :config
    (global-annoying-arrows-mode +1))
#+END_SRC
** Beacon
#+BEGIN_SRC emacs-lisp
  (use-package beacon
    :ensure t
    :config
    (global-key "C-\\" 'beacon-blink))
#+END_SRC
** Don't use `custom`
#+BEGIN_SRC emacs-lisp
(setq-default custom-file "/dev/null")
#+END_SRC
** Crux helper setup
#+BEGIN_SRC emacs-lisp
  (use-package crux
    :ensure t
    :config
    (progn
      (global-key "C-a" #'crux-move-beginning-of-line)
      (global-key "C-o" #'crux-smart-open-line)
      (global-key "C-S-o" #'crux-smart-open-line-above)
      (global-key "C-S-d" #'crux-kill-whole-line)
      (global-key "C-c =" #'crux-indent-defun)
      (prefixed-key "tt" crux-visit-term-buffer)))
#+END_SRC
** Fill Column Indicator
Fill column indicator for showing right ruler.

#+BEGIN_SRC emacs-lisp
  (use-package fill-column-indicator
    :ensure t
    :config
    (enable-minor-mode-globally fci-mode))
#+END_SRC

Fill column indicator interferes with company mode to create UI breakages.
This snippet disables FCI when company mode is on.
#+BEGIN_SRC emacs-lisp
  (defvar-local company-fci-mode-on-p nil)

  (defun company-turn-off-fci (&rest ignore)
    "Turn off FCI for company mode.
  IGNORE: ignore."
    (when (boundp 'fci-mode)
      (setq company-fci-mode-on-p fci-mode)
      (when fci-mode (fci-mode -1))))

  (defun company-maybe-turn-on-fci (&rest ignore)
    "Turn on FCI when company mode is off.
  IGNORE: ignore."
    (when company-fci-mode-on-p (fci-mode +1)))

  (add-hook 'company-completion-started-hook 'company-turn-off-fci)
  (add-hook 'company-completion-finished-hook 'company-maybe-turn-on-fci)
  (add-hook 'company-completion-cancelled-hook 'company-maybe-turn-on-fci)
#+END_SRC
* Which Key?
#+BEGIN_SRC emacs-lisp
(use-package which-key
  :ensure t
  :diminish which-key-mode
  :init (which-key-mode t)
  :config
    (setq which-key-sort-order 'which-key-key-order-alpha
      which-key-side-window-max-width 0.33
      which-key-idle-delay 0.05))
#+END_SRC

* Theme
#+BEGIN_SRC emacs-lisp
  (use-package anti-zenburn-theme
    :ensure t
    :config (load-theme 'anti-zenburn t))
#+END_SRC

Enhance the loaded theme.
#+BEGIN_SRC emacs-lisp
(require 'theme-enhancement)
(theme-enhancement/apply)
#+END_SRC

* Key prefix names
#+BEGIN_SRC emacs-lisp
  (rename-key-prefix "g" "VCS")
  (rename-key-prefix "e" "Errors")
  (rename-key-prefix "p" "Projects")
  (rename-key-prefix "f" "Files")
  (rename-key-prefix "b" "Buffers")
  (rename-key-prefix "w" "Windows")
  (rename-key-prefix "s" "Search")
  (rename-key-prefix "t" "Terminal")
#+END_SRC
* General shortcuts
#+BEGIN_SRC emacs-lisp
  (defhydra windmove-hydra ()
    "windmove"
    ("<left>" windmove-left "left")
    ("<right>" windmove-right "right")
    ("<up>" windmove-up "up")
    ("<down>" windmove-down "down")
    ("h" windmove-left "left")
    ("j" windmove-down "down")
    ("k" windmove-up "up")
    ("l" windmove-right "right"))

  (prefixed-keys
    ("bb" . switch-to-buffer)
    ("bd" . kill-this-buffer)
    ("C-i" . crux-switch-to-previous-buffer)
    ("bn" . next-buffer)
    ("bp" . previous-buffer)
    ("ff" . counsel-find-file)
    ("wd" . delete-window)
    ("wD" . delete-other-window)
    ("wh" . split-window-horizontally)
    ("wv" . split-window-vertically)
    ("ww" . windmove-hydra/body))

  (global-keys
    ("C-S-j" . #'join-next-line)
    ("C-S-k" . #'join-line)
    ("C-S-y" . crux-duplicate-current-line-or-region))
  (global-key "C-x C-b" 'ibuffer)
  (global-key "M-/" 'hippie-expand)

  (global-keys
   ("C-s" . isearch-forward-regexp)
   ("C-r" . isearch-backward-regexp)
   ("C-M-s" . isearch-forward)
   ("C-M-r" . isearch-backward))
#+END_SRC
* Auto-completion
#+BEGIN_SRC emacs-lisp
  (use-package company
    :ensure t
    :config
    (progn
      (global-company-mode t)
      (setq company-show-numbers t)))

  (use-package company-quickhelp
    :ensure t
    :after company
    :config (company-quickhelp-mode +1))
#+END_SRC

* Documentation
#+BEGIN_SRC emacs-lisp
  (use-package eldoc
    :ensure t
    :diminish eldoc-mode
    :config
    (global-eldoc-mode +1))
#+END_SRC
* Spaceline
#+BEGIN_SRC emacs-lisp

;; (use-package spaceline
;;   :ensure t
;;  :config
;;    (require 'spaceline-config)
;;    (spaceline-emacs-theme))
#+END_SRC

* Smart mode line
#+BEGIN_SRC emacs-lisp
  (use-package smart-mode-line
    :ensure t
    :config
      (setq sml/no-confirm-load-theme t)
      (sml/setup))
#+END_SRC
* Syntax Checking
#+BEGIN_SRC emacs-lisp
  (use-package flycheck
    :ensure t
    :init
    (setq flycheck-keymap-prefix (kbd (concat +keybinding/mnemonic-prefix+ " e")))
    :config
    (progn
      (global-flycheck-mode t)
      (rename-key-prefix "e" "Errors")
      (setq flycheck-mode-line-prefix "!")))
#+END_SRC
* Smartparens/Indentation/autopair
** Electric-pair mode
Electric-pair mode closes parenthesis automatically. However, if I'm using
Smartparens/Paredit, no need to use electric pair mode.
#+BEGIN_SRC emacs-lisp
; (electric-pair-mode +1)

#+END_SRC

** Smartparens
Smartparens is generally awesome. It combines the ideas of electric-pair,
paredit, wrap-region, AST navigation etc.
#+BEGIN_SRC emacs-lisp
  (defmacro def-pair (pair)
    "Creates function sp/wrap-with-<PAIR>."
    `(progn (defun ,(read (concat "sp/wrap-with-"
                                  (prin1-to-string (car pair))
                                  "s")) (&optional arg)
              (interactive "p")
              (sp-wrap-with-pair ,(cdr pair)))))

  (def-pair (paren . "("))
  (def-pair (bracket . "["))
  (def-pair (brace . "{"))
  (def-pair (single-quote . "'"))
  (def-pair (double-quote . "\""))
  (def-pair (back-quote . "`"))

  (use-package smartparens-config
    :ensure smartparens
    :diminish (smartparens-mode . " ✓")
    :config
    (smartparens-global-mode +1)

    ;; Setup smartparens in minibuffer
    (setq sp-ignore-modes-list (delete 'minibuffer-inactive-mode sp-ignore-modes-list))
    (sp-local-pair 'minibuffer-inactive-mode "'" nil :actions nil)

    (mode-keys smartparens-mode-map
               ;; Navigation
               ("C-M-a" . sp-beginning-of-sexp)
               ("C-M-e" . sp-end-of-sexp)
               ("C-M-f" . sp-forward-sexp)
               ("C-M-b" . sp-backward-sexp)

               ;; Traversal
               ("C-<down>" . sp-down-sexp)
               ("C-<up>" . sp-up-sexp)
               ("M-<down>" . sp-backward-down-sexp)
               ("M-<up>" . sp-backward-up-sexp)
               ("C-M-n" . sp-next-sexp)
               ("C-M-p" . sp-previous-sexp)
               ("C-S-f" . sp-forward-symbol)
               ("C-S-b" . sp-backward-symbol)

               ;; AST re-arrange.
               ;; ("C-)" . sp-forward-slurp-sexp)
               ("C-)" . sp-slurp-hybrid-sexp)
               ("C-}" . sp-forward-barf-sexp)
               ("C-(" . sp-backward-slurp-sexp)
               ("C-{" . sp-backward-barf-sexp)

               ;; Killing
               ("C-M-k" . sp-kill-sexp)
               ("C-k" . sp-kill-hybrid-sexp)
               ("M-k" . sp-backward-kill-sexp)

               ;; Unknown
               ;; ("C-M-t" . sp-transpose-sexp)
               ;; ("C-M-w" . sp-copy-sexp)
               ;; ("C-M-d" . delete-sexp)
               ;; ("M-<backspace>" . backward-kill-word)
               ;; ("C-<backspace>" . sp-backward-kill-word)
               ;; ([remap sp-backward-kill-word] . backward-kill-word)
               ;; ("M-[" . sp-backward-unwrap-sexp)
               ;; ("M-]" . sp-unwrap-sexp)
               ;; ("C-x C-t" . sp-transpose-hybrid-sexp)

               ;; Wrap
               ;; ("C-c C-w (" . sp/wrap-with-parens)
               ;; ("C-c C-w [" . sp/wrap-with-brackets)
               ;; ("C-c C-w {" . sp/wrap-with-braces)
               ;; ("C-c C-w '" . sp/wrap-with-single-quotes)
               ;; ("C-c C-w \"" . sp/wrap-with-double-quotes)
               ;; ("C-c C-w `" . sp/wrap-with-back-quotes)
               ))
#+END_SRC

** Auto-indentation
#+BEGIN_SRC emacs-lisp
  (electric-indent-mode +1)
#+END_SRC
* Avy
Avy is used to jump around the file.
#+BEGIN_SRC emacs-lisp
  (use-package avy
    :ensure t
    :config
      (key-chord-define-global "jj" 'avy-goto-word-1))
#+END_SRC
* Persistent history
** Minibuffer, M-x and ring history
#+BEGIN_SRC emacs-lisp
  (setq savehist-additional-variables '(kill-ring search-ring regexp-search-ring))
  (setq savehist-file "~/.emacs.d/tmp/history")

  (savehist-mode +1)
#+END_SRC
** Recent files
#+BEGIN_SRC emacs-lisp
  (require 'recentf)
  (recentf-mode +1)
  (setq recentf-max-menu-items 25)

  ;; Save recent files every few minutes.
  (run-at-time nil (* 5 60) 'recentf-save-list)

  ;; Silent the saved recent files message
  (silence-function 'recentf-save-list)
#+END_SRC
* VCS
** Magit

#+BEGIN_SRC emacs-lisp
  (use-package magit
    :ensure t
    :config
    (progn
      (prefixed-key "gs" magit-status)))
#+END_SRC

** Monky
#+BEGIN_SRC emacs-lisp
  (use-package monky
    :ensure t
    :config
    (progn
      (prefixed-key "gh" monky-status)))

#+END_SRC
** VC-mode
Use `C-x v` prefixed commands for now.
** Highlight diff
#+BEGIN_SRC emacs-lisp
  (use-package diff-hl
    :ensure t
    :config
    (progn
      (enable-minor-mode-globally diff-hl-mode)
      (enable-minor-mode-globally diff-hl-flydiff-mode)
      (add-hook 'magit-post-refresh-hook 'diff-hl-magit-post-refresh)))
#+END_SRC
** SMerge keybindings
#+BEGIN_SRC emacs-lisp
  (defhydra hydra-smerge
    (:color green)
    "
  ^Move^	^Keep^	^Aux^	^Diff^
  ------------------------------------------------------
  _n_ext	_b_ase	_R_efine	_<_: base-mine	_q_uit
  _p_rev	_m_ine	_E_diff	_=_: mine-other	_RET_: current
  ^ ^	_o_ther	_C_ombine	_>_: base-other
  ^ ^	_a_ll	_r_esolve"
    ("RET" smerge-keep-current)
    ("C" smerge-combine-with-next)
    ("E" smerge-ediff)
    ("R" smerge-refine)
    ("a" smerge-keep-all)
    ("b" smerge-keep-base)
    ("m" smerge-keep-mine)
    ("n" smerge-next)
    ("o" smerge-keep-other)
    ("p" smerge-prev)
    ("r" smerge-resolve)
    ("<" smerge-diff-base-mine)
    ("=" smerge-diff-mine-other)
    (">" smerge-diff-base-other)
    ("q" nil :color red))

  (prefixed-mode-key smerge-mode-map "m" hydra-smerge/body)
#+END_SRC
* Projectile
#+BEGIN_SRC emacs-lisp
  (use-package projectile
    :ensure t
    :init
    (progn
      (setq projectile-enable-caching t)
      (setq projectile-keymap-prefix (kbd (concat +keybinding/mnemonic-prefix+ " p"))))
    :config
    (progn
      (projectile-global-mode +1)
      (setq projectile-completion-system 'ivy)
      (setq projectile-mode-line '(:eval (format " P[%s]" (projectile-project-name))))))
#+END_SRC
* Snippets
#+BEGIN_SRC emacs-lisp
  (use-package yasnippet
    :ensure t
    :diminish yas-minor-mode
    :config
    (progn
      (yas-global-mode +1)
      (prefixed-key "is" yas-expand)))
#+END_SRC
* Rainbow parens
Multi-colored parantheses are helpful, especially in lisp-like modes.
#+BEGIN_SRC emacs-lisp
  (show-paren-mode +1)

  (use-package rainbow-delimiters
    :ensure t
    :config
    (enable-minor-mode-globally rainbow-delimiters-mode))
#+END_SRC
* Spell check
#+BEGIN_SRC emacs-lisp
  (use-package flyspell
    :ensure t
    :diminish (flyspell-mode . " _")
    :config
    (progn
      (setq ispell-program-name (locate-file "aspell" exec-path))
      (setq ispell-list-command "--list")
      (add-hook 'text-mode-hook #'(lambda () (flyspell-mode +1)))))
#+END_SRC
* Org mode setup
** Org agenda
#+BEGIN_SRC emacs-lisp
(setq org-agenda-files '("~/organizer/main.org"))
#+END_SRC
** Org bullets
#+BEGIN_SRC emacs-lisp
  (use-package org-bullets
    :ensure t
    :diminish org-bullets-mode
    :config
    (add-hook
     'org-mode-hook
     (lambda () (org-bullets-mode +1))))
#+END_SRC
** Org indent
#+BEGIN_SRC emacs-lisp
  (use-package org-indent
    :ensure t
    :diminish org-indent-mode
    :config
    (add-hook 'org-mode-hook (lambda () (org-indent-mode +1))))
#+END_SRC
** Org capture
#+BEGIN_SRC emacs-lisp
  (setq org-capture-templates
        '(("a" "Action Item" entry (file+headline "~/organizer/main.org" "Action Items")
           "* TODO %?\n  %i")
          ("c" "Calendar" entry (file+headline "~/organizer/main.org" "Calendar")
           "* %?\n %^T\n %i")
          ("r" "Reference" entry (file "~/organizer/reference.org")
           "* %?\n  %i\n%^{prompt|Description}\n\n:PROPERTIES:\n:RecordDate:\t%T\n:END:"
           :prepend t
           :empty-lines 1)))

  (global-key "<f6>" 'org-capture)
  (global-key "C-c c" 'org-capture)
#+END_SRC
** Org refile
#+BEGIN_SRC emacs-lisp
(setq org-refile-targets '((org-agenda-files . (:maxlevel . 6))))
#+END_SRC
* TODO Lang setup [6/13]
** DONE C/C++
*** Irony Mode
Irony mode is clang based autocompletion and syntax checker. It is like YouCompleteMe, but only for C-family and better.
I've had many problems with the YCM setup at work.

#+BEGIN_SRC emacs-lisp
  (use-package irony
    :ensure t
    :init
    (progn
      (add-hook 'c++-mode-hook 'irony-mode)
      (add-hook 'c-mode-hook 'irony-mode)
      (add-hook 'objc-mode-hook 'irony-mode))
    :config
    (add-hook 'irony-mode-hook 'irony-cdb-autosetup-compile-options))
#+END_SRC

*** Completion
#+BEGIN_SRC emacs-lisp
  (use-package company-irony
    :ensure t
    :after company
    :after irony
    :config
    (add-to-list 'company-backends 'company-irony))

  (use-package company-irony-c-headers
    :ensure t
    :after company
    :after irony
    :config
    (add-to-list 'company-backends 'company-irony-c-headers))

  ;; Company-clang doesn't work well with the work setup.
  (setq company-backends (delete 'company-clang company-backends))
#+END_SRC

*** Syntax checker
#+BEGIN_SRC emacs-lisp
  (use-package flycheck-irony
    :ensure t
    :after flycheck
    :after irony
    :config
    (add-hook 'flycheck-mode-hook #'flycheck-irony-setup))
#+END_SRC

*** Eldoc
#+BEGIN_SRC emacs-lisp
  (use-package irony-eldoc
    :ensure t
    :after irony
    :config
    (add-hook 'irony-mode-hook #'irony-eldoc))
#+END_SRC

*** Coding style
#+BEGIN_SRC emacs-lisp
  (use-package google-c-style
    :ensure t
    :config
    (add-hook 'c-mode-common-hook 'google-set-c-style))
#+END_SRC

*** Navigation using RTags
RTags is a great navigation framework for C++. Unfortunately, it doesn't handle gargantuan codebases from cloud filesystems like work.
Still, good to have in config.
#+BEGIN_SRC emacs-lisp
  (use-package rtags
    :ensure t
    :config
    (progn
      ;; Can't do it since this is not compatible with work. Also, irony-mode is pretty good.
      (setq rtags-completions-enabled nil)

      (setq rtags-autostart-diagnostics t)
      (rtags-enable-standard-keybindings)))

  ;; Maybe someday.
  ;;
  ;; (use-package company-rtags
  ;;   :ensure t
  ;;   :after company
  ;;   :after rtags
  ;;   :config
  ;;   (add-to-list 'company-backends 'company-rtags))
#+END_SRC

*** TODO Explore cmake-ide

*** TODO Set up debugger
** TODO common-lisp
** DONE Emacs Lisp
#+BEGIN_SRC emacs-lisp
  ;; Helper functions.
  (defun elisp-visit-ielm ()
    "Switch to default `ielm' buffer.
  Start `ielm' if it's not already running."
    (interactive)
    (crux-start-or-switch-to 'ielm "*ielm*"))

  (defun elisp-recompile-elc-on-save ()
    "Recompile your elc when saving an elisp file."
    (add-hook
     'after-save-hook
     (lambda ()
       (when (and (file-exists-p (byte-compile-dest-file buffer-file-name)))
         (emacs-lisp-byte-compile)))
     nil
     t))

  (defun emacs-lisp-mode-setup ()
    "Setup for emacs-lisp mode."
    (elisp-recompile-elc-on-save)
    (setq mode-name "ELisp"))

  (add-hook 'emacs-lisp-mode-hook #'emacs-lisp-mode-setup)

  (use-package elisp-slime-nav
    :ensure t
    :diminish elisp-slime-nav-mode
    :config
    (dolist (hook '(emacs-lisp-mode-hook ielm-mode-hook))
      (add-hook hook 'turn-on-elisp-slime-nav-mode)))

  (define-key emacs-lisp-mode-map (kbd "C-c C-z") 'elisp-visit-ielm)
  (define-key emacs-lisp-mode-map (kbd "C-c C-c") 'eval-defun)
  (define-key emacs-lisp-mode-map (kbd "C-c C-b") 'eval-buffer)
  (define-key emacs-lisp-mode-map (kbd "C-c C-r") 'eval-region)
#+END_SRC
** TODO Go
** TODO Haskell
Add libraries for XMonad.
#+BEGIN_SRC emacs-lisp
(add-to-list 'flycheck-ghc-search-path (expand-file-name "~/.xmonad/lib"))
#+END_SRC
** TODO HTML emmet
** TODO JS
** Java meghanada
#+BEGIN_SRC emacs-lisp
  (use-package meghanda
    :ensure t
    :config
    (progn
      (add-hook 'java-mode-hook #'(lambda () (meghanada-mode +1)))))
#+END_SRC
** TODO latex
** TODO markdown
** DONE Protocol buffers
#+BEGIN_SRC emacs-lisp
  (use-package protobuf-mode
    :ensure t
    :init
    (add-hook
     'protobuf-mode-hook
     #'(lambda ()
         (setq
          imenu-generic-expression
          '((nil "^[[:space:]]*\\(message\\|service\\|enum\\)[[:space:]]+\\([[:alnum:]]+\\)" 2))))))
#+END_SRC
** DONE Python
*** Python mode setup
#+BEGIN_SRC emacs-lisp
  (use-package python
    :ensure t
    :config
    (setq python-shell-interpreter "ipython"
          python-shell-interpreter-args "--simple-prompt -i"))
#+END_SRC

*** Anaconda setup
#+BEGIN_SRC emacs-lisp
  (use-package anaconda-mode
    :ensure t
    :diminish anaconda-mode
    :diminish anaconda-eldoc-mode
    :config
    (anaconda-mode +1))

  (use-package company-anaconda
    :ensure t
    :config
    (add-to-list 'company-backends 'company-anaconda))
#+END_SRC

*** Virtualenv
#+BEGIN_SRC emacs-lisp
  (use-package virtualenvwrapper
    :ensure t
    :config
    (progn
      (setq eshell-prompt-function
         (lambda () (concat venv-current-name " $ ")))
      (venv-initialize-interactive-shells)
      (venv-initialize-eshell)))

  (use-package pyenv-mode
    :ensure t
    :after virtualenvwrapper
    :config
    (pyenv-mode +1))
#+END_SRC

*** Formatter
#+BEGIN_SRC emacs-lisp
  (use-package py-yapf
    :ensure t)

#+END_SRC

*** Testing
#+BEGIN_SRC emacs-lisp
  (use-package pytest
    :ensure t)
#+END_SRC
*** TODO Setup ein
** DONE Shell

Setup for Bash and Zsh files
#+BEGIN_SRC emacs-lisp
  (defconst +zsh-filename-patterns+
    '("\\.zsh\\'"
      "zlogin\\'"
      "zlogout\\'"
      "zpreztorc\\'"
      "zprofile\\'"
      "zshenv\\'"
      "zshrc\\'")
    "Filename patterns for Zsh script files.")

  (use-package sh-script
    :defer t
    :init
    (progn
      (dolist (pattern +zsh-filename-patterns+)
        (add-to-list 'auto-mode-alist (cons pattern 'sh-mode)))
      (add-hook
       'sh-mode-hook
       #'(lambda ()
         (when
             (and
              buffer-file-name
              (cl-mapcar #'(lambda (pat) (string-match-p pat buffer-file-name)) +zsh-filename-patterns+))
           (sh-set-shell "zsh"))))))
#+END_SRC

Code completion
#+BEGIN_SRC emacs-lisp
  (use-package company-shell
    :ensure t
    :after company
    :config
    (add-hook
     'sh-mode-hook
     #'(lambda ()
       (add-to-list
        (make-local-variable 'company-backends)
        'company-shell))))
#+END_SRC

Insert shebang
#+BEGIN_SRC emacs-lisp
  (use-package insert-shebang
    :ensure t
    :config
    (progn
      ;; Don't insert shebang proactively.
      (remove-hook 'find-file-hook 'insert-shebang)))
#+END_SRC

** DONE ESS (Statistics/R)
#+BEGIN_SRC emacs-lisp
  (use-package ess
    :ensure t
    :config
    (progn
      (add-hook
       'inferior-ess-mode-hook
       #'(lambda nil
           (define-key inferior-ess-mode-map [\C-up]
             'comint-previous-matching-input-from-input)
           (define-key inferior-ess-mode-map [\C-down]
             'comint-next-matching-input-from-input)
           (define-key inferior-ess-mode-map [\C-x \t]
             'comint-dynamic-complete-filename)))))
#+END_SRC
* Semantic
** Stickyfunc
#+BEGIN_SRC emacs-lisp
  (use-package stickyfunc-enhance
    :ensure t)
#+END_SRC

** Srefactor
#+BEGIN_SRC emacs-lisp
  (use-package srefactor
    :ensure t)
#+END_SRC

** Semantic setup
#+BEGIN_SRC emacs-lisp
  (setq semantic-default-submodes
        '( ;; Perform semantic actions during idle time
          global-semantic-idle-scheduler-mode
          ;; Use a database of parsed tags
          global-semanticdb-minor-mode
          ;; Decorate buffers with additional semantic information
          global-semantic-decoration-mode
          ;; Highlight the name of the function you're currently in
          global-semantic-highlight-func-mode
          ;; show the name of the function at the top in a sticky
          global-semantic-stickyfunc-mode
          ;; Generate a summary of the current tag when idle
          ; global-semantic-idle-summary-mode

          ;; Show a breadcrumb of location during idle time
          global-semantic-idle-breadcrumbs-mode
          ;; Switch to recently changed tags with `semantic-mrub-switch-tags',
          ;; or `C-x B'
          global-semantic-mru-bookmark-mode))

  (add-hook 'emacs-lisp-mode-hook 'semantic-mode)
  (add-hook 'python-mode-hook 'semantic-mode)
  (add-hook 'java-mode-hook 'semantic-mode)
  (add-hook 'c-mode-hook 'semantic-mode)
  ;; etc etc
  (add-hook 'prog-mode-hook 'semantic-mode)
#+END_SRC

** Emacs Refactor
#+BEGIN_SRC emacs-lisp
  (use-package emr
    :ensure t
    :config
    (progn
      (add-hook 'prog-mode-hook 'emr-initialize)
      (mode-key prog-mode-map "M-RET" emr-show-refactor-menu)))
#+END_SRC
* TODO Tags
* Search
** Ag
#+BEGIN_SRC emacs-lisp
  (use-package ag
    :ensure t)
#+END_SRC
** Swiper
#+BEGIN_SRC emacs-lisp
  (prefixed-key "ss" swiper)
  (key-chord-define-global "??" 'swiper)
#+END_SRC
* TODO Iedit
* Anzu
Anzu is good for interactive search and replace.
#+BEGIN_SRC emacs-lisp
(use-package anzu
  :ensure t
  :diminish anzu-mode
  :config (global-anzu-mode +1))
#+END_SRC
* Evil
Don't use evil mode for general purpose. Current use of evil mode is for vim like search/replace only. Toggle as necessary.
#+BEGIN_SRC emacs-lisp
(use-package evil
  :ensure t)
#+END_SRC

* Undo-tree
#+BEGIN_SRC emacs-lisp
(use-package undo-tree
  :ensure t
  :diminish undo-tree-mode)
#+END_SRC
* TODO Gnus
* TODO ERC
* Load machine configuration
#+BEGIN_SRC emacs-lisp
  (load-file "~/.emacs.machine.el")
#+END_SRC
